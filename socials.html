<!DOCTYPE html>
<html>
	<head>
		<title>Socials</title>
		<link rel="stylesheet" href="style.css" />
		<link rel="icon" href="img/icon.jpg" type="image/x-icon" />
	</head>
	<body style="overflow: hidden; display: flex; flex-direction: column;">
		<h1>Зв'язок зі мною</h1>
		<table align="center">
			<tr>
				<th>
					<button class="footer-button" style="margin: 2px" onclick="window.open('https://t.me/bloodbern', '_blank')">My Telegram</button>
				</th>
			</tr>
			<tr>
				<th>
					<button class="footer-button" style="margin: 2px" onclick="window.open('https://instagram.com/bloodbern', '_blank')">My Instagram</button>
				</th>
			</tr>
			<tr>
				<th>
					<button class="footer-button" style="margin: 2px" onclick="window.open('mailto:bloodbern09@gmail.com', '_blank')">Напишіть мені!</button>
				</th>
			</tr>
			<tr>
				<th>
					<button id="play-button" class="footer-button" style="margin: 2px" onclick="startGame()"></button>
				</th>
			</tr>
		</table>

		<div id="game">
			<span id="game-time"></span>
			<div id="health-display"></div>
			<div id="ramen-sign-container">
				<div id="ramen-sign-mount"></div>
				<div id="ramen-sign">ラーメン</div>
			</div>
			<div id="shop">
				<div id="shop-counter"></div>
				<div id="shop-wall"></div>
			</div>
			<div id="food-items-container"></div>
			<div id="chopsticks-container">
				<div class="chopstick"></div>
				<div class="chopstick">
					<div id="chopsticks-hitbox"></div>
				</div>
			</div>
			<div id="right-wall"></div>
			<div id="conveyor">
				<div class="conveyor-wheel">
					<div></div>
				</div>
				<div class="conveyor-wheel">
					<div></div>
				</div>
			</div>
			<div id="low-hp-overlay"></div>
		</div>

		<script>
			//Глобальні константи
			const gravity = 2; //прискорення вільного падіння, px/frame
			const horizontalDamping = 0.97; //коефіцієнт зниження горизонтальної швидкості
			const terminalVelocity = 50; //максимальна швидкість падіння, px/frame
			const inertialMultiplier = 1.3; //при відпусканні предмету швидкість трошки збільшується

			const initialHealth = 3;

			const initialSpawnInterval = 1500; //базова затримка спавну, ms
			const minSpawnInterval = 500; //мінімальна затримка спавну, ms
			const initialSpawnVariation = 1000; //максимальна додаткова затримка спавну, ms
			const spawnIntervalSpeedUp = 10; //значення, на яке spawnInterval і spawnVariation зменшуються після кожного спавну, ms

			const conveyorSpeed = 3; //горизонтальна швидкість конвеєра, px/frame

			//дістаємо всі необхідні елементи з html
			const playButton = document.getElementById("play-button");
			const game = document.getElementById("game");
			const gameTime = document.getElementById("game-time");
			const healthDisplay = document.getElementById("health-display");
			const foodItemsContainer = document.getElementById("food-items-container");
			const chopsticksContainer = document.getElementById("chopsticks-container");
			const chopsticksHitbox = document.getElementById("chopsticks-hitbox");
			const rightWall = document.getElementById("right-wall");
			const conveyor = document.getElementById("conveyor");
			const lowHpOverlay = document.getElementById("low-hp-overlay");

			//ініціалізуємо глобальні змінні
			let foodItems = []; //Масив FoodItems
			let caughtFoodItem = null; //FoodItem, що зараз прикріплений до паличок

			let mainLoop = null; //id основного ігрового інтервалу
			let health = 0; //поточне здоров'я
			let gameStartTimestamp = 0; //точний час початку гри, ms

			//фукнція старту гри, викликається при натисканні кнопки
			function startGame() {
				//якщо основний цикл ініціалізовано (гра запущена):
				if (mainLoop) {
					//зупиняємо гру:
					//---очищаємо основний цикл
					clearInterval(mainLoop);

					mainLoop = null;

					//задеспавнимо всі FoodItems
					for (const foodItem of foodItems) {
						foodItem.despawn();
					}
					//очищаємо утримуваний FoodItem
					caughtFoodItem = null;
					//очищаємо всі серця
					healthDisplay.replaceChildren([]);
					//приховуємо червоний оверлей
					lowHpOverlay.classList.remove("visible");
				}
				//якщо основний цикл НЕ ініціалізовано (гра НЕ запущена):
				else {
					//розпочинаємо гру:
					//записуємо поточний точний час
					gameStartTimestamp = Date.now();

					//ініціалізуємо базовий інтервал спавну та варіацію за допомогою констант
					let spawnInterval = initialSpawnInterval;
					let spawnVariation = initialSpawnVariation;

					//ініціалізуємо наступну позначки часу появи (через 1 с)
					let nextSpawnTimestamp = gameStartTimestamp + 1000;

					//ініціалізуємо здоров'я
					health = initialHealth;

					//запуск і призначення основного циклу (функція запускається кожен кадр)
					mainLoop = setInterval(() => {
						const timestamp = Date.now(); //беремо поточну позначку часу

						//оновлюємо час гри
						gameTime.innerText = formatTime(timestamp - gameStartTimestamp);

						//переглядаємо FoodItems
						for (const foodItem of foodItems) {
							//якщо FoodItem зараз утримується палочками - нічого не робити
							if (foodItem === caughtFoodItem) {
								continue;
							}
							//інакше:
							foodItem.move(); //перемістити предмет

							//якщо FoodItem ще НЕ на конвеєрі і не перекриває його - нічого не робити
							if (foodItem.isOnConveyor || !elementsOverlapping(foodItem.image, conveyor)) {
								continue;
							}
							//інакше: встановлюємо isOnConveyor
							foodItem.isOnConveyor = true;
						}

						//якщо поточний час більший за мітку часу появи:
						if (timestamp > nextSpawnTimestamp) {
							//спавнимо предмет
							const foodItem = new FoodItem(); //створюємо об'єкт класу FoodItem

							foodItem.spawn(); //викликаємо метод spawn

							//готуємо наступну мітку часу появи:
							//поточний час + інтервал появи + [0 - варіант появи]
							//наприклад: 2375274356982 + 1500 + 643
							nextSpawnTimestamp = timestamp + spawnInterval + (Math.random() * spawnVariation);

							//зменшуємо інтервал появи та варіацію за допомогою spawnIntervalSpeedUp
							//
							//    переконуємось, що він не нижче мінімального інтервалу
							//                     |
							//                    \/
							spawnInterval = Math.max(spawnInterval - spawnIntervalSpeedUp, minSpawnInterval);
							spawnVariation = Math.max(spawnVariation - spawnIntervalSpeedUp, 0);
						}
					}, 16.666666); // оброблюємо в 60 фпс (1000 ms / 60 frames - interval of 16.6(6) ms)

					//створюємо піктограми здоров’я
					for (let i = 0; i < initialHealth; i++) {
						//створюємо HTML-елемент
						const heart = document.createElement("img");

						//призначаємо джерело значка
						heart.src = "https://cdn-icons-png.flaticon.com/512/1762/1762755.png";

						//вставляємо в "контейнер" здоров'я
						healthDisplay.appendChild(heart);
					}
				}

				//Незалежно від стану гри:
				//перемикаємо видимість ігрової зони
				game.classList.toggle("running"); //якщо "running" вже є в списку класів - видаляємо його, інакше - додаємо

				updatePlayButtonText();
			}

			function updatePlayButtonText() {
				//використовуємо тернарний оператор, щоб змінити текст всередині кнопки Play
				playButton.innerText = mainLoop ? "I don't wanna play anymore :(" : "Shall we play a game? :)";
			};

			//функція перевіряє, чи розташований елемент вище (на осі z) іншого елемента
			function elementsOverlapping(element1, element2) {
				//getBoundingClientRect - повертає координати 4 сторін елемента HTML (зліва, справа, зверху, знизу)
				const rect1 = element1.getBoundingClientRect();
				const rect2 = element2.getBoundingClientRect();

				return rect1.right > rect2.left &&
					rect1.left < rect2.right &&
					rect1.bottom > rect2.top &&
					rect1.top < rect2.bottom;
			}

			//перетворюємо час у мілісекундах на "HH:MM:SS.sss" (ISO 8601)
			function formatTime(milliseconds) {
				return [ // 1. створюємо масив, заповнюємо години, хвилини та секунди, витягнуті з позначки часу
					Math.floor(milliseconds / 60 / 60 / 1000),
					Math.floor(milliseconds / 60 / 1000) % 60,
					Math.floor(milliseconds / 1000) % 60,
				]
					.map((value) => String(value).padStart(2, "0")) // 2. перетворюємо кожне значення в рядок, додаємо початкові нулі
					.filter((value, index) => value !== "00" || index > 0) // 3. відкидуємо години, якщо значення дорівнює "00"
					.join(":") // 4. об’єднуємо години, хвилини та секунди в рядок: "HH:MM:SS"
					.concat(".") // 5. додаємо крапку: "HH:MM:SS."
					.concat(String(milliseconds % 60).padStart(3, "0")) // 6. додаємо мілісекунди, з початковими нулями
			}

			class FoodItem {
				constructor() {
					//ініціалізація масиву з джерелами зображень
					const images = [
						"https://cdn-icons-png.flaticon.com/512/3259/3259041.png",
						"https://cdn-icons-png.flaticon.com/512/2515/2515345.png",
						"https://cdn-icons-png.flaticon.com/512/2718/2718224.png",
						"https://cdn-icons-png.flaticon.com/512/3361/3361870.png",
						"https://cdn-icons-png.flaticon.com/512/2713/2713962.png"
					].toSorted(() => 0.5 - Math.random()); // <- "випадково" сортуємо

					//довжина сторони зображення
					const width = 80;

					//створюємо і запускаємо елемент зображення
					const image = document.createElement("img");
					image.classList.add("game-food-item");
					image.src = images[0];
					image.style.width = `${width}px`;
					image.style.top = `${Math.random() * (foodItemsContainer.clientHeight / 2)}px`; // set random vertical position

					//призначаємо змінні цьому об’єкту
					this.image = image;

					this.size = width;

					//встановлюємо випадкову початкову швидкість
					this.velocity = {
						x: 5 + Math.random() * 10,
						y: -10 - (Math.random() * 20)
					};
					this.previousGrabPosition = {
						x: 0,
						y: 0
					};

					this.isOnConveyor = false;
				}

				//спавнимо FoodItem у ігровій зоні
				spawn() {
					foodItemsContainer.appendChild(this.image); //втсалвєяом в контейнер FoodItem
					foodItems.push(this); //додаємо до масиву продуктів харчування

					new Audio('sounds/woosh_s21KzKN.mp3').play(); //відтворити звуковий ефект
				}

				//присвоюємо "фізику" щоб переміщати предмет
				move() {
					//якщо на конвеєрі:
					if (this.isOnConveyor) {
						//використовуватимуться style.bottom
						this.image.style.top = null;

						//перемістити трохи вправо
						this.image.style.left = `${this.image.offsetLeft + conveyorSpeed}px`;
						//переконуємось, що предмет знаходиться на конвеєрі
						this.image.style.bottom = `${conveyor.offsetHeight}px`;
					}
					//інакше:
					else {
						//переконуємось, чи торкаємося ми правої стіни:
						if (elementsOverlapping(rightWall, this.image)) {
							//якщо так, встановлюємо швидкість, щоб зробити відскок
							this.velocity = {
								x: -25,
								y: -55
							};
						}

						//оновлюємо позицію FoodItem
						this.image.style.left = `${this.image.offsetLeft + this.velocity.x}px`;
						this.image.style.top = `${this.image.offsetTop + this.velocity.y}px`;

						//застосовуємо перетягування до горизонтального руху
						this.velocity.x *= horizontalDamping;
						//додаємо силу тяжіння та переконуємось, що швидкість нижча від кінцевої
						this.velocity.y = Math.min(this.velocity.y + gravity, terminalVelocity);
					}

					//після завершення руху перевіряємо, чи потрібно деспавнити предмет
					this.tryDespawn();
				}

				//вручну оновлюємо позицію FoodItem
				setPosition(x, y) {
					//по-перше, переміщаємо предмет у вказані координати
					this.image.style.left = `${x - this.size / 2}px`;
					this.image.style.top = `${y - this.size / 2}px`;

					//записуємо нову позицію
					const newGrabPosition = {
						x: this.image.offsetLeft,
						y: this.image.offsetTop
					};
					//віднімаємо з попередньої позиції
					this.velocity = {
						x: (newGrabPosition.x - this.previousGrabPosition.x) * inertialMultiplier,
						y: (newGrabPosition.y - this.previousGrabPosition.y) * inertialMultiplier
					};
					//оновлюємо поточну позицію
					this.previousGrabPosition = newGrabPosition;

					//перевіряємо, чи потрібно деспавнити предмет
					this.tryDespawn();
				}

				tryDespawn() {
					//якщо предмет знаходиться всередині ігрової зони - нічого не робимо
					if (this.image.offsetTop < game.clientHeight &&
						this.image.offsetLeft < game.clientWidth) {
						return;
					}
					//інакше - деспавним
					this.despawn();

					//дивимось, чи втратили ми здоров’я:
					//якщо предмет стоїть на конвеєрі - вмикаємо звуковий ефект і закінчуємо на цьому
					//тобто, цей предмет було переміщено за межі ігрової зони конвеєром
					if (this.isOnConveyor) {
						new Audio('sounds/anime-wow-sound-effect.mp3').play();

						return;
					}
					//інакше, якщо предмет випав за межі ігрової зони:
					//забираємо одне очко здоров'я
					healthDisplay.firstElementChild.remove();

					//програємо звук "програшу"
					new Audio('sounds/classic_hurt.mp3').play();

					//перевіряємо наявність сердець
					if (--health > 0) {
						//якщо серця є, і воно лише одне ->
						if (health === 1) {
							// -> показуємо оверлей низького здоров'я
							lowHpOverlay.classList.add("visible");
						}
						return;
					}
					//інакше, якщо ми втратили всі серця, закінчуємо гру
					startGame();
					//показуємо діалогове вікно
					alert(`You are lost!\nYou lasted: ${formatTime(Date.now() - gameStartTimestamp)}`);
				}

				//вилучаємо FoodItem з контейнера та масиву
				despawn() {
					foodItemsContainer.removeChild(this.image);
					foodItems = foodItems.filter(foodItem => foodItem !== this);
				}

				catch(x, y) {
					this.setPosition(x, y);

					this.velocity = {
						x: 0,
						y: 0
					};

					caughtFoodItem = this;
				}

				release() {
					caughtFoodItem = null;
				}
			}

			//обробники подій:
			//викликається щоразу, коли ми переміщуємо мишу в ігрову область
			game.addEventListener("mousemove", event => {
				//вираховуємо координати курсору в ігровій зоні
				const cursorPosition = {
					x: event.clientX - game.offsetLeft,
					y: event.clientY - game.offsetTop
				};
				//оновлюємо позицію паличок
				for (const chopstick of chopsticksContainer.children) {
					chopstick.style.left = `${Math.max(cursorPosition.x, 0)}px`;
					chopstick.style.top = `${Math.max(cursorPosition.y, 60)}px`;
				}
				//
				//
				//якщо FoodItem утримується паличками для їжі, оновлюємо його положення
				//і використовуємо необов’язковий процес – по суті, це перевірка, чи
				//caughtFoodItem має значення null/undefined перед викликом функції
				//
				//
				caughtFoodItem?.setPosition(cursorPosition.x, cursorPosition.y);
			});

			//використовуються, щоб показати/приховати курсор миші під час виходу/входу в ігрову зону
			game.addEventListener("mouseenter", event => {
				game.style.cursor = "none";
			});
			game.addEventListener("mouseleave", event => {
				game.style.cursor = null;
			});

			//кнопку миші натиснуто:
			game.addEventListener("mousedown", event => {
				//обраховуємо координати курсору в ігровій зоні
				const cursorPosition = {
					x: event.clientX - game.offsetLeft,
					y: event.clientY - game.offsetTop
				};

				//відтворюємо анімацію "хапання"
				chopsticksContainer.firstElementChild.classList.add("grab");

				//ітеруємо всі FoodItems
				for (const foodItem of foodItems) {
					if (!elementsOverlapping(chopsticksHitbox, foodItem.image)) {
						continue;
					}
					//якщо FoodItem накладається на хітбокс паличок - хапаємо предмет
					foodItem.catch(cursorPosition.x, cursorPosition.y);
				}
			});

			//кнопку миші відпущено:
			game.addEventListener("mouseup", event => {
				//зупиняємо анімацію "хапання"
				chopsticksContainer.firstElementChild.classList.remove("grab");
				//відпускаємо предмет в паличках, якщо він є
				caughtFoodItem?.release(event.movementX, event.movementY);
			});

			//відображаємо початковий текст на кнопці відтворення
			updatePlayButtonText();
		</script>
	</body>
</html>